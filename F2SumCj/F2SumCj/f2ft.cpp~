
using namespace std;

#include <ilcplex/ilocplex.h>
ILOSTLBEGIN

#include <iostream>
#include <vector>

#define MAX_JOBS 200

struct Job {
  int id;
  int ptime[2];
};

void 
read_jobs(const char *fname, vector<Job>& N)
{
  N.resize(0);
  ifstream ifs(fname);
  if( ifs.is_open() ) {
    int Nr_jobs;
    Job buf;
    ifs>>Nr_jobs;
    for(int i=0; i<Nr_jobs; ++i) {
      buf.id=i;
      ifs>>buf.ptime[0]>>buf.ptime[1];
      cout<<"Here"<<endl;
      cout<<buf.ptime[0]<<"\t"<<buf.ptime[1]<<endl;
      N.push_back(buf);
    }
  }
  else {
    char msg[128];
    snprintf(msg, 127, "read_jobs(): cannot open %s", fname );
    throw(msg);
  }
}


int main(int argc, char *argv[])
{
  int res=EXIT_SUCCESS;
  try {
    if( argc<2 ) {
      throw("Please provide a file name");
    }

    vector<Job> N;
    read_jobs(argv[1], N);

    cout<<N.size()<<" jobs"<<endl;

    IloEnv env;
    IloModel model(env);

    IloIntVarArray x[MAX_JOBS];
    for(int i=0; i<N.size(); ++i) {
      char buf[128];
      x[i]=IloIntVarArray(env, N.size(), 0.0, 1.0);
      for(int j=0; j<N.size(); ++j) {
	snprintf(buf, 127, "x(%d,%d)", i, j);
	x[i][j].setName(buf);
      }
    }

    IloNumVarArray Ctime[2];
    Ctime[0]=IloNumVarArray(env, N.size(), 0.0, IloInfinity);
    Ctime[1]=IloNumVarArray(env, N.size(), 0.0, IloInfinity);
    for(int i=0; i<N.size(); ++i) {
      char buf[128];
      snprintf(buf, 127, "C(0,%d)", i);
      cout<<buf<<endl;
      Ctime[0][i].setName(buf);
      snprintf(buf, 127, "C(1,%d)", i);
      cout<<buf<<endl;
      Ctime[1][i].setName(buf);
    }

    IloExpr obj(env);
    obj.clear();
    for(int i=0; i<N.size(); ++i)
      obj+=Ctime[1][i];
    model.add(IloMaximize(env, obj));

    for(int i=0; i<N.size(); ++i) {
      IloExpr e(env);
      for(int j=0; j<N.size(); ++j) {
	e+=x[i][j];
      }
      model.add(e==1.0);
    }

    for(int j=0; j<N.size(); ++j) {
      IloExpr e(env);
      for(int i=0; i<N.size(); ++i) {
	e+=x[i][j];
      }
      model.add(e==1.0);
    }


    for(int pos=0; pos<N.size(); ++pos) {
      IloExpr tmp(env), tmp2(env), tmp3(env);
      tmp.clear();
      tmp2.clear();
      tmp3.clear();
      for(int i=0; i<N.size(); ++i) {
	tmp+=N[i].ptime[0]*x[i][pos];
	tmp2+=N[i].ptime[1]*x[i][pos];
	tmp3+=N[i].ptime[1]*x[i][pos];
      }
      if( !pos ) {
	model.add(Ctime[0][0]>=tmp);
	model.add(Ctime[1][0]>=Ctime[0][0]+tmp2);
      }
      else {
	model.add(Ctime[0][pos]>=Ctime[0][pos-1]+tmp);
	model.add(Ctime[1][pos]>=Ctime[1][pos-1]+tmp2);
	model.add(Ctime[1][pos]>=Ctime[0][pos]+tmp3);
      }
    }
    IloCplex cpx(model);

    cpx.exportModel("pippo.lp");


  }

  catch(const char *s) {
    cerr<<s<<endl;
    res=EXIT_FAILURE;
  }
  catch(IloException e) {
    cerr<<e<<endl;
    res=EXIT_FAILURE;
  }
  catch(...) {
    cerr<<"Unhandled exception, my friend!"<<endl;
    res=EXIT_FAILURE;
  }

  return res;
}
